Перем СимвИсключения, КонстантыMSXML, ПространстваИмен;
//*******************************************
Функция ПостроитьУзелПоОписаниюТипа(хмлПарсер, хмлНаборСхем, Тип, ЛокальноеИмя) Экспорт Далее
Функция СериализоватьОбъектРекурсивно(Объект, хмлПарсер, хмлКорень, Знач хмлНаборСхем,
	хмлШаблон="", спОбъектов="", URIПрефикс="myType", ОписаниеТипа="", Ид="") Экспорт Далее
//*******************************************
Функция Тест()
	
	Возврат """глмХМЛ"" - подключен";
	
КонецФункции	
//*******************************************
Функция Дата2Строка(ВыбДата, Время="")
	
	ДатаФормат = Прав("000" + ДатаГод(ВыбДата), 4) 
		+ "-" + Прав("0" + ДатаМесяц(ВыбДата), 2) 
		+ "-" + Прав("0" + ДатаЧисло(ВыбДата), 2) 
		+ "T" + ?(Время="", "00:00:00", Время);
		
	Возврат ?(ДатаФормат = "0000-00-00T00:00:00",
		"0001-01-01T00:00:00", ДатаФормат);
	
КонецФункции
//*******************************************
Функция СоздатьНаборСхем(хмлНаборСхем)
	
	Попытка
		хмлНаборСхем = СоздатьОбъект("Msxml2.XMLSchemaCache.6.0");
	Исключение
		Сообщить(ОписаниеОшибки(), "!");
		Возврат 0;
	КонецПопытки;	
	
	Возврат 1;
	
КонецФункции
//*******************************************
Функция СоздатьПарсер(хмлПарсер)
	
	Попытка
		хмлПарсер = СоздатьОбъект("Msxml2.DOMDocument.6.0");
	Исключение
		Сообщить(ОписаниеОшибки(), "!");
		Возврат 0;
	КонецПопытки;	
	
	Возврат 1;
	
КонецФункции	
//*******************************************
Функция СоздатьДокумент(хмлПарсер, хмлНаборСхем) Экспорт
	
	Результат = ?(ТипЗначенияСтр(хмлНаборСхем)="OLE.IXMLDOMSchemaCollection2", 
		1, СоздатьНаборСхем(хмлНаборСхем)) * СоздатьПарсер(хмлПарсер);
	
	Если Результат = 1 Тогда
		
		хмлПарсер.Schemas = хмлНаборСхем;
		
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции	
//*******************************************
Функция ДобавитьАтрибут(хмлПарсер, хмлУзел, Ид, Значение) Экспорт
	
	хмлАтрибут = хмлПарсер.createAttribute(Ид);
	хмлАтрибут.value = Значение;
	хмлУзел.setAttributeNode(хмлАтрибут);
	
	Возврат 1;
	
КонецФункции
//*******************************************
Функция ПолучитьАтрибут(хмлУзел, Ид) Экспорт
	
	Возврат хмлУзел.getAttribute(Ид);
	
КонецФункции
//*******************************************
Функция СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень, 
	ИмяКорневогоУзла="ROOT", Кодировка="windows-1251") Экспорт
	
	Результат = СоздатьДокумент(хмлПарсер, хмлНаборСхем);
	
	Если Результат = 1 Тогда
		хмлПарсер.appendChild(хмлПарсер.createProcessingInstruction("xml", 
			"version='1.0' encoding='" + Кодировка + "'"));
		
		хмлКорень = хмлПарсер.appendChild(хмлПарсер.createElement(ИмяКорневогоУзла));
		// в дальнейшем: продумать прогрузку контекста пространства имен
		ДобавитьАтрибут(хмлПарсер, хмлКорень, 
			"xmlns:xs", "http://www.w3.org/2001/XMLSchema");
		ДобавитьАтрибут(хмлПарсер, хмлКорень, 
			"xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции	
//*******************************************
Функция ДобавитьСхемуИзФайла(хмлНаборСхем, URIПространстваИмен, ИмяФайла) Экспорт
	
	Возврат ?(Число(хмлНаборСхем.add(URIПространстваИмен, ИмяФайла))=0,1,0);
	
КонецФункции	
//*******************************************
Функция ЗагрузитьСхемыПоСписку(хмлНаборСхем, спНаборСхем="") Экспорт
	Перем URIПространстваИмен, ИмяФайла;
	
	Если ТипЗначенияСтр(спНаборСхем)="СписокЗначений" Тогда
		Для й = 1 По спНаборСхем.РазмерСписка() Цикл
			ИмяФайла = спНаборСхем.ПолучитьЗначение(й, URIПространстваИмен);
			Если ДобавитьСхемуИзФайла(хмлНаборСхем, 
				URIПространстваИмен, ИмяФайла) = 0 Тогда
					Возврат 0;
			КонецЕсли;		
		КонецЦикла;
	КонецЕсли;	
	
	Возврат 1;
	
КонецФункции	
//*******************************************
Функция ПрочитатьДокументИзСтроки(хмлПарсер, хмлНаборСхем, спНаборСхем="", Стр="") Экспорт
	
	Попытка
		Результат = СоздатьДокумент(хмлПарсер, хмлНаборСхем)
			* ЗагрузитьСхемыПоСписку(хмлНаборСхем, спНаборСхем);
	Исключение
		Возврат 0;
	КонецПопытки;
	
	Если Результат = 0 Тогда
		Возврат Результат;
	КонецЕсли;	

	хмлПарсер.async = 0;
	хмлПарсер.SetProperty("MultipleErrorMessages", 1);
    хмлПарсер.loadXML(Стр);
	
	Ошибки = хмлПарсер.ParseError;
	Если Ошибки.ErrorCode <> 0 Тогда
		Результат = 0;
		Для й = 0 По Ошибки.AllErrors.length - 1 Цикл
			Ошибка = Ошибки.AllErrors(й);
			Сообщить("Ошибка: " + Лев(Ошибка.Reason 
				+ " " + Ошибка.SrcText, 350));
		КонецЦикла;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции	
//*******************************************
Функция ПрочитатьДокументИзФайла(хмлПарсер, хмлНаборСхем, спНаборСхем="", ИмяФайла="") Экспорт
	
	Попытка
		Результат = СоздатьДокумент(хмлПарсер, хмлНаборСхем)
			* ЗагрузитьСхемыПоСписку(хмлНаборСхем, спНаборСхем);
	Исключение
		Возврат 0;
	КонецПопытки;
	
	Если Результат = 0 Тогда
		Возврат Результат;
	КонецЕсли;	

	хмлПарсер.async = 0;
	хмлПарсер.SetProperty("MultipleErrorMessages", 1);
    хмлПарсер.load(ИмяФайла);
	
	Ошибки = хмлПарсер.ParseError;
	Если Ошибки.ErrorCode <> 0 Тогда
		Результат = 0;
		Для й = 0 По Ошибки.AllErrors.length - 1 Цикл
			Ошибка = Ошибки.AllErrors(й);
			Сообщить("Ошибка: " + Ошибка.Reason 
				+ " " + Ошибка.SrcText);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции	
//*******************************************
Функция ВывестиДокументВСтроку(хмлПарсер) Экспорт
	
	Возврат хмлПарсер.xml;
	
КонецФункции	
//*******************************************
Функция ВывестиДокументВФайл(хмлПарсер, ИмяФайла) Экспорт
	
	Попытка
		хмлПарсер.save(ИмяФайла);
		
	Исключение
		Сообщить("Ошибка: " + ОписаниеОшибки(), "!");
		Возврат 0;
		
	КонецПопытки;
	
	Возврат 1;
	
КонецФункции
//*******************************************
Функция ПолучитьСхему(хмлНаборСхем, URIПространстваИмен)
	
	Возврат хмлНаборСхем.getSchema(URIПространстваИмен);
	
КонецФункции
//*******************************************
Функция ПолучитьОписаниеТипаСхемы(хмлНаборСхем, URIПространстваИмен, ИмяТипа) Экспорт
	
	Возврат ПолучитьСхему(хмлНаборСхем, URIПространстваИмен)
		.types.itemByName(ИмяТипа);
	
КонецФункции	
//*******************************************
Процедура ПостроитьРеквизитыУзлаПоОписаниюТипа(хмлПарсер, хмлНаборСхем, хмлУзел, хмлМодельКонтента) Экспорт
	
	Для Н = 1 По хмлМодельКонтента.particles.length Цикл
		
		хмлЭлементКонтента = хмлМодельКонтента.particles(Н-1);

		Если КонстантыMSXML.Получить(хмлЭлементКонтента.itemType)
			= "SOMITEM_ANY" Тогда
				
		ИначеЕсли КонстантыMSXML.Получить(хмлЭлементКонтента.itemType) 
			= "SOMITEM_ELEMENT" Тогда
				
				хмлОписаниеРеквизита = хмлЭлементКонтента;
                
				Если (хмлОписаниеРеквизита.type.name <> "NCName") Тогда
						
					Для К = 1 По Число(хмлОписаниеРеквизита.minOccurs) Цикл
						хмлРеквизит = ПостроитьУзелПоОписаниюТипа(хмлПарсер, хмлНаборСхем, 
							хмлОписаниеРеквизита.type, хмлОписаниеРеквизита.name);

						хмлУзел.appendChild(хмлРеквизит);
					КонецЦикла;
					
				КонецЕсли;
		Иначе  
			
			ПостроитьРеквизитыУзлаПоОписаниюТипа(хмлПарсер, хмлНаборСхем, хмлУзел, хмлЭлементКонтента);
			
		КонецЕсли;
		
	КонецЦикла;		

КонецПроцедуры	
//*******************************************
Функция ПостроитьУзелПоОписаниюТипа(хмлПарсер, хмлНаборСхем, Тип, ЛокальноеИмя) Экспорт

	Алиас = ПространстваИмен.Получить(Тип.namespaceURI);

	ИмяУзла = ?(ПустоеЗначение(Алиас) = 0, Алиас + ":", "") + ЛокальноеИмя;

	хмлУзел = хмлПарсер.createElement(ИмяУзла);

	Если СокрЛП(Тип.name) = "" Тогда
		Если КонстантыMSXML.Получить(Тип.itemType) 
			= "SOMITEM_COMPLEXTYPE" Тогда

				хмлОписаниеТипа = Тип;

		Иначе
			Возврат хмлУзел;
		КонецЕсли;
	Иначе	
		Попытка

			хмлОписаниеТипа = ПолучитьОписаниеТипаСхемы(хмлНаборСхем, 
				Тип.namespaceURI, Тип.name);

		Исключение
			//ДобавитьАтрибут(хмлПарсер, хмлУзел, "xsi:type", 
			//	Тип.namespaceURI + ":" + Тип.name);	
			Возврат хмлУзел;		
		КонецПопытки;
	КонецЕсли;
	
	Если КонстантыMSXML.Получить(хмлОписаниеТипа.itemType) 
		= "SOMITEM_COMPLEXTYPE" Тогда
			
			хмлМодельКонтента = хмлОписаниеТипа.contentModel;
						
			ПостроитьРеквизитыУзлаПоОписаниюТипа(хмлПарсер,	хмлНаборСхем, 
				хмлУзел, хмлМодельКонтента);
			
	КонецЕсли;
	
	Возврат хмлУзел;
	
КонецФункции	
//*******************************************
Функция ВыполнитьПреобразование(хмлАргумент, хмлНаборСхем, хмлФункция, хмлРезультат) Экспорт
	
	Результат = СоздатьДокумент(хмлРезультат, хмлНаборСхем);
	
	Если Результат = 1 Тогда
		
		хмлРезультат.async = 0;
		//хмлРезультат.validateOnParse = -1;
		хмлРезультат.SetProperty("MultipleErrorMessages", 1);
		
		Попытка
			хмлАргумент.transformNodeToObject(хмлФункция, хмлРезультат);
			Ошибки = хмлРезультат.ParseError;
			Если Ошибки.ErrorCode <> 0 Тогда
				Результат = 0;
				Для й = 0 По Ошибки.AllErrors.length - 1 Цикл
					Ошибка = Ошибки.AllErrors(й);
					Сообщить("Ошибка: " + Лев(Ошибка.Reason 
						+ " " + Ошибка.SrcText, 350));
				КонецЦикла;
			КонецЕсли;
		Исключение
			Сообщить("Ошибка: " 
				+ Лев(ОписаниеОшибки(),350));
			Результат = 0;
		КонецПопытки;	
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции
//*******************************************
Функция СериализоватьЗначение(Значение, хмлПарсер, хмлКорень, 
	Знач хмлНаборСхем, хмлШаблон="", флРекурсии=0) Экспорт
	Перем Метка;
	
	Результат = 1;
	
	Если ТипЗначенияСтр(Значение) = "ТаблицаЗначений" Тогда
		
		хмлТаблица = хмлКорень.appendChild(хмлПарсер.createElement("ТаблицаЗначений"));
		
		ДобавитьАтрибут(хмлПарсер, хмлТаблица, 
			"xmlns:xs", "http://www.w3.org/2001/XMLSchema");
		ДобавитьАтрибут(хмлПарсер, хмлТаблица, 
			"xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
		ДобавитьАтрибут(хмлПарсер, хмлТаблица, 
			"xmlns:myType", "http://my.org/torg");
		
		Для НомСтр = 1 По Значение.КоличествоСтрок() Цикл
			
			хмлСтрока = хмлТаблица.appendChild(хмлПарсер.createElement("Строка"));
			
			хмлНомерСтроки = хмлСтрока.appendChild(хмлПарсер.createElement("НомерСтроки"));
			хмлНомерСтроки.text = НомСтр;
			
			Для НомКол = 1 По Значение.КоличествоКолонок() Цикл
				
				Метка = Значение.ПолучитьПараметрыКолонки(НомКол);
				
				хмлКолонка = хмлСтрока.appendChild(хмлПарсер.createElement(Метка));

				Результат = Результат * СериализоватьЗначение(Значение
					.ПолучитьЗначение(НомСтр, НомКол), хмлПарсер, хмлКолонка, 
						хмлНаборСхем, хмлШаблон, 0);
			КонецЦикла;
			
		КонецЦикла;	
        
		Если флРекурсии = 1 Тогда
			Результат = Результат * СериализоватьОбъектРекурсивно(хмлТаблица, 
				хмлПарсер, хмлКорень, "", хмлШаблон, "", "myType", "", "");
		КонецЕсли;
			
	ИначеЕсли ТипЗначенияСтр(Значение) = "СписокЗначений" Тогда

		хмлСписок = хмлКорень.appendChild(хмлПарсер.createElement("СписокЗначений"));
		
		ДобавитьАтрибут(хмлПарсер, хмлСписок, 
			"xmlns:xs", "http://www.w3.org/2001/XMLSchema");
		ДобавитьАтрибут(хмлПарсер, хмлСписок, 
			"xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
		ДобавитьАтрибут(хмлПарсер, хмлСписок, 
			"xmlns:myType", "http://my.org/torg");
			
		Для Поз = 1 По Значение.РазмерСписка() Цикл
			
			ТекЗнач = Значение.ПолучитьЗначение(Поз, Метка);
			
			хмлУзел = хмлСписок.appendChild(хмлПарсер.createElement(Метка));
			
			Результат = Результат * СериализоватьЗначение(ТекЗнач, 
				хмлПарсер, хмлУзел, хмлНаборСхем, хмлШаблон, 0);
	
		КонецЦикла;	

		Если флРекурсии = 1 Тогда
			Результат = Результат * СериализоватьОбъектРекурсивно(хмлСписок, 
				хмлПарсер, хмлКорень, "", хмлШаблон, "", "myType", "", "");
        КонецЕсли;

	ИначеЕсли ТипЗначения(Значение) < 10 Тогда

		Если ТипЗначенияСтр(Значение) = "Дата" Тогда
			хмлКорень.text = Дата2Строка(Значение);	
		ИначеЕсли ТипЗначенияСтр(Значение) = "Число" Тогда
			// квалификаторы числа хорошо бы брать из свойств реквизита
			хмлКорень.text = Формат(Значение, "Ч15.3.");
		Иначе
			Попытка
			хмлКорень.text = Значение;
			Исключение
			КонецПопытки;
		КонецЕсли;
		
    ИначеЕсли ТипЗначения(Значение) < 100 Тогда
	    
		Ид = глмМетаданные.Ссылка2Ид(Значение);
		хмлКорень.text = Ид;
		стрТипРеквизита = глмМетаданные.Ид2Тип(Ид);
		Если стрТипРеквизита <> "0." Тогда
			ДобавитьАтрибут(хмлПарсер, хмлКорень, 
				"xsi:type", "myType:" + стрТипРеквизита);
		КонецЕсли;
		Попытка	
		ДобавитьАтрибут(хмлПарсер, хмлКорень, 
			"view", "" + ?(Значение.Вид() = "Номенклатура", 
				глмОбщиеФункции.ПолнНаименованиеТовара(Значение), Значение));	
		Исключение
		КонецПопытки;	
			
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции
//*******************************************
Функция СериализоватьОбъект(Объект1С, хмлПарсер, хмлНаборСхем, хмлУзел, 
	ОписаниеТипа="", сИд="") Экспорт

	Если ТипЗначения(Объект1С) = 11 Тогда
		ОбъектМенеджер = СоздатьОбъект("Справочник." 
			+ Объект1С.Вид());

		ОбъектМенеджер.НайтиЭлемент(Объект1С);
		
		Если ОбъектМенеджер.Блокировка() = 1 Тогда
		// мне достаточно просто знать, что не заблокирован	
			Возврат 0;
		КонецЕсли;
		
	ИначеЕсли ТипЗначения(Объект1С) = 12 Тогда
		ОбъектМенеджер = СоздатьОбъект("Документ." 
			+ Объект1С.Вид());

		ОбъектМенеджер.НайтиДокумент(Объект1С);
		
		Если ОбъектМенеджер.Блокировка() = 1 Тогда
			Возврат 0;
		КонецЕсли;
		
	Иначе
		ОбъектМенеджер = "";
		
	КонецЕсли;	
	
	//Если ОбъектМенеджер <> "" Тогда
	//	Если ОбъектМенеджер.Блокировка(1) = 0 Тогда
	//	// при безуспешной попытка заблокировать документ,
	//	// откладываем его обработку
	//		Сообщить("Объект """ + Объект1С 
	//			+ """ заблокирован", "!");
	//			
	//		Возврат 0;
	//		
	//	КонецЕсли;	
	//КонецЕсли;
	
	Ид = глмМетаданные.Ссылка2Ид(Объект1С);
	
	Если СокрЛП(ОписаниеТипа) <> "" Тогда
		Текст = СтрЗаменить(ОписаниеТипа, ":", РазделительСтрок);
		хмлУзел = хмлПарсер.createElement(СтрПолучитьСтроку(Текст, 2));
	
	Иначе
		хмлУзел = хмлПарсер.createElement(глмМетаданные.Ид2Тип(Ид));
	
	КонецЕсли;	
	//
	ДобавитьАтрибут(хмлПарсер, хмлУзел, 
		"xmlns:xs", "http://www.w3.org/2001/XMLSchema");
	ДобавитьАтрибут(хмлПарсер, хмлУзел, 
		"xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
	ДобавитьАтрибут(хмлПарсер, хмлУзел, 
		"xmlns:myType", "http://my.org/torg");
	//\\
	хмлСсылки = хмлУзел.appendChild(хмлПарсер
		.createElement("Ref"));
	хмлСсылки.text = ?(сИд="", Ид, сИд);	
	
	Если СтрЧислоВхождений(глмМетаданные.Ид2Тип(Ид), "Перечисление.")>0 Тогда
		Значение = глмМетаданные.ВыбратьЗначения(Ид, Объект1С.Идентификатор());
		Свойства = глмМетаданные.ВыбратьСвойстваЗначения(Значение, Ид);
		//хмлКаталога = хмлУзел.appendChild(хмлПарсер
		//	.createElement("СвойстваЗначения"));
		хмлКаталога = хмлУзел;
		//\\
		Свойства.ВыбратьСтроки();
		Пока Свойства.ПолучитьСтроку() = 1 Цикл
			хмлСекцииРеквизита = хмлКаталога.appendChild(хмлПарсер
				.createElement(Свойства.Имя));
			хмлСекцииРеквизита.text = Свойства.Значение;
		КонецЦикла;
	ИначеЕсли СтрЧислоВхождений(глмМетаданные.Ид2Тип(Ид), "Справочник.")>0 Тогда
		Объект1С.ИспользоватьДату(ТекущаяДата(), 1);
	КонецЕсли;	
	
	Реквизиты = глмМетаданные.ВыбратьРеквизиты(Ид, "", "", "");
	
	ГруппыРеквизитов = СоздатьОбъект("ТаблицаЗначений");
	
	Реквизиты.Выгрузить(ГруппыРеквизитов,,, "ИдКаталога");
	ГруппыРеквизитов.Свернуть("ИдКаталога","");
	
	ГруппыРеквизитов.ВыбратьСтроки();
	Пока ГруппыРеквизитов.ПолучитьСтроку() = 1 Цикл
		Если ГруппыРеквизитов.ИдКаталога 
			= "РеквизитТабличнойЧасти" Тогда
				Продолжить;
		КонецЕсли;
		РеквизитыГруппы = глмТаблицыЗначений.ВыбратьПоЗначению(Реквизиты, 
			"ИдКаталога", ГруппыРеквизитов.ИдКаталога);
		
		//хмлКаталога = хмлУзел.appendChild(хмлПарсер
		//		.createElement(ГруппыРеквизитов.ИдКаталога));	
		хмлКаталога = хмлУзел;
		//\\
		РеквизитыГруппы.ВыбратьСтроки();
		Пока РеквизитыГруппы.ПолучитьСтроку() = 1 Цикл
			Значение = Объект1С.ПолучитьАтрибут(РеквизитыГруппы.Ид);
			// другого решения, похоже не сделать: кривизна
			// связана с тем, что дата документа - реквизит, 
			// время - метод)))  
			Если РеквизитыГруппы.Ид = "ДатаДок" Тогда
				Если ТипЗначения(Объект1С) = 12 Тогда
					Значение = Дата2Строка(Значение, 
						Объект1С.ПолучитьВремя()); 
				КонецЕсли;	
			КонецЕсли;
			//\\
			хмлСекцииРеквизита = хмлКаталога.appendChild(хмлПарсер
				.createElement(РеквизитыГруппы.Ид));
			
			СериализоватьЗначение(Значение, хмлПарсер, 
				хмлСекцииРеквизита, хмлНаборСхем, "");
				
		КонецЦикла;	
	КонецЦикла;	
	
	НС=0; Если ГруппыРеквизитов.НайтиЗначение("РеквизитТабличнойЧасти", 
		НС, "ИдКаталога") = 1 Тогда
			РеквизитыГруппы = глмТаблицыЗначений.ВыбратьПоЗначению(Реквизиты, 
				"ИдКаталога", "РеквизитТабличнойЧасти");
		    // тут, возможно, лучше сделать как в 8-ке, копировать 
			// группу РТЧ-реквизиты со значениями каждый раз по числу
			// строк в документе - было бы, кстати, проще с шаблонами...
			//хмлКаталога = хмлУзел.appendChild(хмлПарсер
			//	.createElement("РеквизитТабличнойЧасти"));
				
		    Объект1С.ВыбратьСтроки();
			Пока Объект1С.ПолучитьСтроку() = 1 Цикл
				//хмлСтрока = хмлКаталога.appendChild(хмлПарсер
				//	.createElement("row" + Объект1С.НомерСтроки));
				хмлСтрока = хмлУзел.appendChild(хмлПарсер
					.createElement("РеквизитТабличнойЧасти"));
				
				РеквизитыГруппы.ВыбратьСтроки();
				Пока РеквизитыГруппы.ПолучитьСтроку() = 1 Цикл
					Значение = Объект1С.ПолучитьАтрибут(РеквизитыГруппы.Ид);
			
					хмлСекцииРеквизита = хмлСтрока.appendChild(хмлПарсер
						.createElement(РеквизитыГруппы.Ид));
						
					СериализоватьЗначение(Значение, хмлПарсер, 
						хмлСекцииРеквизита, хмлНаборСхем, "");

				КонецЦикла;
			КонецЦикла;	
	КонецЕсли;	
	
	//Если ОбъектМенеджер <> "" Тогда
	//// снять блокировку с объекта
	//	ОбъектМенеджер.Блокировка(0);
	//КонецЕсли;

	Возврат 1;
	
КонецФункции
//*******************************************
// Поиск записей регистра соответствий идентификаторов 
// в распределенной информационной базе
//	Параметры:
//		Ид - идентификатор отбора
//		Напр - направление, 0: поиск собственного 
//			идентификатора по заданному внешнему
//			1 или другое значение: поиск внешнего 
//			идентификатора по собственному
//
Функция ВыбратьОбъектыПоСоотв(Ид, Напр = 0)
	Перем ГУИд, СубИд, КодУзла;
	
	Соответствия = СоздатьОбъект("ТаблицаЗначений");
// идентификатор объекта	
	Соответствия.НоваяКолонка("ГУИд");
// запись соответствия, если найдена
	Соответствия.НоваяКолонка("СсылкаСоотв");
	
	тИд = СтрЗаменить(Ид, ":", РазделительСтрок);
	
	КолвоЗнач = СтрКоличествоСтрок(тИд);
	
	ГУИд = СтрПолучитьСтроку(тИд, КолвоЗнач);
	
	Если КолвоЗнач > 1 Тогда
// идентификатор формата КодУзла:ГУИд
		КодУзла = СтрПолучитьСтроку(тИд, 1);
		Если КолвоЗнач > 2 Тогда
// идентификатор формата КодУзла:СубИд:ГУИд
			СубИд = СтрПолучитьСтроку(тИд, 2);
		КонецЕсли;
	Иначе	
// передан искомый идентификатор объекта		
		Соответствия.НоваяСтрока();
		Соответствия.ГУИд = ГУИд;
        Возврат Соответствия;
	КонецЕсли;	
	
	Если КодУзла = "000" Тогда
// передан искомый идентификатор объекта,
// в общем формате - нет информации по узлу
		Соответствия.НоваяСтрока();
		Соответствия.ГУИд = ГУИд;
        Возврат Соответствия;
	КонецЕсли;	

    ТекстЗапроса = 
	"SELECT " + ?(Напр = 0, 
		"$СпрСоотв.ВнутренняяСсылка", 
		"$СпрСоотв.GUID") + " AS ГУИд,
	|	СпрСоотв.ID AS [СсылкаСоотв $Справочник.СоотвОбъектовДляОбмена]
	|FROM
	|	$Справочник.СоотвОбъектовДляОбмена AS СпрСоотв
	|WHERE 
	|	$СпрСоотв." + ?(Напр = 0, 
			"GUID", "ВнутренняяСсылка") + "= '" + СокрЛП(ГУИд) + "' " 
	+ ?((СубИд = "*") ИЛИ (ПустоеЗначение(СубИд) = 1), 
		"", " AND $СпрСоотв.SubGUID = " + СокрЛП(СубИд)) 
	+ 		" AND $СпрСоотв.Узел = '" + КодУзла + "'";
	
	Соответствия = глмOLEDBQuery
		.ВыполнитьИнструкцию(ТекстЗапроса, 
			"", 1, 0, 0, 0);

// в случае, если задан код узла, вернет запись 
// соответствия и ГУИд объекта, в соответствии с
// заданным направлением поиска "Напр"
	Возврат Соответствия;
	
КонецФункции	
//*******************************************
// Формат Ид: КодУзла(С3):Идентификатор(С40) - полный
// или Идентификатор(С40) - сокращенный в пределах своей
// информационной базы
//
Функция НайтиОбъект(Знач Ид)
	
	ТЗ = ВыбратьОбъектыПоСоотв(Ид, 0);
	Если ТЗ.КоличествоСтрок() > 0 Тогда
		
		ВнутИд = СокрЛП(ТЗ.ПолучитьЗначение(1,1));
// возвращаем значение ссылочного типа		
		Возврат глмМетаданные.Ид2Ссылка(ВнутИд);
		
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции	
//*******************************************
Функция НайтиСоответствие(Знач Ид)
	
	ТЗ = ВыбратьОбъектыПоСоотв(Ид, 1);
	Если ТЗ.КоличествоСтрок() > 0 Тогда
		
		ВнутИд = СокрЛП(ТЗ.ПолучитьЗначение(1,1));
// возвращаем значение строкового типа 
//- идентификатор внешней ссылки
		Возврат ВнутИд;
		
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции	
//*******************************************
Функция УстановСоответствие(Знач ВнешИд, Знач ВнутИд, Голос=0)
	
	Результат = 1;
	
	Если Голос <> 0 Тогда

		Сообщить("Установка соответствия: """
			+ ВнешИд + """->""" + ВнутИд + """");
	КонецЕсли;	
	
	тИд = СтрЗаменить(ВнешИд, ":", РазделительСтрок);

	Если СтрКоличествоСтрок(тИд) = 1 Тогда
		
		Если Голос <> 0 Тогда
			Сообщить("Установка не выполнена: "
				+ "передан формат внутреннего Ид");
		КонецЕсли;
			
	Иначе	
	
		КодУзла = СтрПолучитьСтроку(тИд, 1);
		
		Если КодУзла = "000" Тогда
			
			Если Голос <> 0 Тогда
				Сообщить("Установка не выполнена: "
					+ "передан код внутреннего узла");
			КонецЕсли;

		Иначе	
			
		    Объект = НайтиОбъект(ВнешИд);
            
			Если ПустоеЗначение(Объект) = 0 Тогда
			
				Если Голос <> 0 Тогда
					Сообщить("Установка не выполнена: "
						+ "найден объект """ + Объект + """");
				КонецЕсли;
			
			Иначе
				
				спрСоотв = СоздатьОбъект("Справочник.СоотвОбъектовДляОбмена");
				
				спрСоотв.Новый();
				спрСоотв.GUID = СтрПолучитьСтроку(тИд, 3);
				спрСоотв.SubGUID = СтрПолучитьСтроку(тИд, 2);
				спрСоотв.Узел = КодУзла;
				спрСоотв.ВнутренняяСсылка = ВнутИд;
			    спрСоотв.ТипЗнач = глмМетаданные.Ид2Тип(ВнутИд);
				
				Попытка
					спрСоотв.Записать();

					Если Голос <> 0 Тогда
						Сообщить("Записано соответствие");
					КонецЕсли;

				Исключение
					Результат = 0;

					Если Голос <> 0 Тогда
						Сообщить("Установка не выполнена: "
							+ ОписаниеОшибки(), "!");
					КонецЕсли;

				КонецПопытки;

			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции	
//*******************************************
Функция ЗначениеАтрибута(Конт, хмлАтрибут)
	
	Значение = хмлАтрибут.text;
	
	Тип = ТипЗначения(Конт.ПолучитьАтрибут(хмлАтрибут.tagName)); 
	
	Если (Тип = 10) или (Тип = 11) или (Тип = 12) Тогда
		Значение = НайтиОбъект(хмлАтрибут.text);
	
	ИначеЕсли Тип = 3 Тогда
		Значение = Дата(Сред(хмлАтрибут.text, 9, 2) 
			+ "." + Сред(хмлАтрибут.text, 6, 2)
				+ "." + Лев(хмлАтрибут.text, 4));
	
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции	
//*******************************************
Функция УстановитьАтрибутыКонтекста(Конт, хмлУзел, ТипОбъекта)
	
	Если ТипОбъекта = 11 Тогда
		Конт.ИспользоватьДату(ТекущаяДата());
	Иначе	
		Если Метаданные.Документ(Конт.Вид())
			.РеквизитТабличнойЧасти() <> 0 Тогда 
				Конт.УдалитьСтроки();
		КонецЕсли;		
	КонецЕсли;	
	
	Для номГруппы = 1 По хмлУзел.childNodes.length - 1 Цикл
		
		хмлГруппаРеквизитов = хмлУзел.childNodes(номГруппы);
		Если хмлГруппаРеквизитов.tagName <> "РеквизитТабличнойЧасти" Тогда
			хмлАтрибут = хмлГруппаРеквизитов;
			Если хмлАтрибут.tagName = "Ref" Тогда
				Продолжить;
			КонецЕсли;	

			Значение = ЗначениеАтрибута(Конт, хмлАтрибут);
			
			// запись владельца элемента:
			Если (хмлАтрибут.tagName = "Владелец") 
				и (ТипОбъекта = 11) Тогда
					Попытка
						Конт.ИспользоватьВладельца(Значение);
					Исключение
						Если ТипЗначенияСтр(Конт) 
							<> "ГрупповойКонтекст" Тогда
								Возврат 0;
						КонецЕсли;
					КонецПопытки;	
			Иначе
			//	
			    Попытка
					Конт.УстановитьАтрибут(хмлАтрибут.tagName, Значение);
				Исключение
					Если ТипЗначенияСтр(Конт) 
						<> "ГрупповойКонтекст" Тогда
							Возврат 0;
					КонецЕсли;
				КонецПопытки;	
			КонецЕсли;	
			//\\
		Иначе	

			Конт.НоваяСтрока();
			Для номРекв = 0 По хмлГруппаРеквизитов.childNodes.length - 1 Цикл
				
				хмлАтрибут = хмлГруппаРеквизитов.childNodes(номРекв);
				
				Значение = ЗначениеАтрибута(Конт, хмлАтрибут);
			
				Попытка
					Конт.УстановитьАтрибут(хмлАтрибут.tagName, Значение);
				Исключение
					Если ТипЗначенияСтр(Конт) 
						<> "ГрупповойКонтекст" Тогда
							Возврат 0;
					КонецЕсли;
				КонецПопытки;	
			КонецЦикла;	
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат 1;
	
КонецФункции	
//*******************************************
Функция ПрочитатьОбъект(МенеджерОбъекта1С, хмлПарсер, хмлНаборСхем, хмлУзел, Записать = 1) Экспорт
	
	МенеджерОбъекта1С = СоздатьОбъект(хмлУзел.tagName); 
	// как-то нужно нивелировать этот патч, т.к. он содержит параметры
	Попытка
		// из внешней программы
		хмлПарсер.setProperty("SelectionLanguage", "XPath");
		хмлПарсер.setProperty("SelectionNamespaces", "xmlns:myType='http://my.org/torg'");
	    хмлСсылка = хмлУзел.selectNodes("myType:Ref").item(0);
	Исключение
		// ... внутренний
		хмлСсылка = хмлУзел.getElementsByTagName("Ref").item(0);
	КонецПопытки;	
	//\\
	Ссылка = НайтиОбъект(хмлСсылка.text);
	
	Если ПустоеЗначение(Ссылка) = 1 Тогда
		МенеджерОбъекта1С.Новый();
	Иначе
		Если ТипЗначения(Ссылка) = 11 Тогда
			МенеджерОбъекта1С.НайтиЭлемент(Ссылка);
		Иначе
			МенеджерОбъекта1С.НайтиДокумент(Ссылка);
			МенеджерОбъекта1С.СделатьНеПроведенным();
		КонецЕсли;	
	КонецЕсли;
	
	Если УстановитьАтрибутыКонтекста(МенеджерОбъекта1С, 
		хмлУзел, ТипЗначения(Ссылка)) = 0 Тогда
			Возврат 0;
	КонецЕсли;	
	
	Если Записать = 1 Тогда
		Попытка
			МенеджерОбъекта1С.Записать();
			УстановСоответствие(хмлСсылка.text, 
				глмМетаданные.Объект2Ид(МенеджерОбъекта1С));
		Исключение
			Сообщить(ОписаниеОшибки());
			Возврат 0;
		КонецПопытки;	
	КонецЕсли;
	
	Возврат 1;
	
КонецФункции
//*******************************************
Функция ПрочитатьЗначение(Значение, Знач хмлПарсер, Знач хмлНаборСхем, Знач хмлУзел, Записать = 1) Экспорт
// совсем по-хорошему, здесь нужно было 
// ориентироваться на схему данных и 
// описание типов объектов в файле, но это 
// "ломало" бы всю "тему" с шаблонами 
// преобразований, по крайней мере, на первый
// взгляд, шаблоны бы выглядели сложнее...
	Если хмлУзел.childNodes.length = 0 Тогда
		
		Возврат 0;
		
	ИначеЕсли хмлУзел.tagName = "ТаблицаЗначений" Тогда
		
		Значение = СоздатьОбъект(хмлУзел.tagName);

		хмлСтроки = хмлУзел.childNodes;
		Для номСтр = 1 По хмлСтроки.length Цикл

			хмлСтрока = хмлСтроки.item(номСтр - 1);
			
			Значение.НоваяСтрока();
			
			хмлКолонки = хмлСтрока.childNodes;
			Для номКол = 1 По хмлКолонки.length Цикл
				
				хмлКолонка = хмлКолонки.item(номКол - 1);
				
				Если номСтр = 1 Тогда
					Значение.НоваяКолонка(хмлКолонка.tagName);
				КонецЕсли;	
				
				ЗначЯчейки = "";
				Если ПрочитатьЗначение(ЗначЯчейки, хмлПарсер, 
					хмлНаборСхем, хмлКолонка, Записать) = 1 Тогда
// если таблица значений должна содержать
// вложенную таблицу, тогда эту таблицу
// нужно размещать первой колонкой - не
// знаю, почему по-другому работать не 
// будет, наверное, это особенность 
// реализации MSXML 6-й версии
						Значение.УстановитьЗначение(номСтр, 
							номКол, ЗначЯчейки);
				КонецЕсли;			
			КонецЦикла;
		КонецЦикла;	
		
	ИначеЕсли хмлУзел.tagName = "СписокЗначений" Тогда
		
		Значение = СоздатьОбъект(хмлУзел.tagName);
		
		хмлСтроки = хмлУзел.childNodes;
		Для номСтр = 1 По хмлСтроки.length Цикл
			
			хмлЗначСписка = хмлСтроки.item(номСтр - 1);
			
			ЗначСписка = "";
			
			Если ПрочитатьЗначение(ЗначСписка, хмлПарсер, 
				хмлНаборСхем, хмлЗначСписка, Записать) = 1 Тогда
					
					Значение.Установить(хмлЗначСписка.tagName, 
						ЗначСписка);
						
			КонецЕсли;			
		КонецЦикла;	
		
	ИначеЕсли Строка(хмлУзел.childNodes.item(0)) 
		= "OLE.IXMLDOMElement" Тогда
// чтение сложного типа, переданного по
// структуре данных реквизитов
		Если (хмлУзел.childNodes.item(0).tagName 
			= "ТаблицаЗначений") 
			ИЛИ (хмлУзел.childNodes.item(0).tagName 
				= "СписокЗначений") Тогда

				Возврат ПрочитатьЗначение(Значение, хмлПарсер, 
					хмлНаборСхем, хмлУзел.childNodes
						.item(0), Записать);

		Иначе
			
			Возврат ПрочитатьОбъект(Значение, хмлПарсер, 
				хмлНаборСхем, хмлУзел.childNodes
					.item(0), Записать);

		КонецЕсли;
	Иначе	
// чтение простых типов, в том числе, ссылок 
// любого типа
		Значение = хмлУзел.text;
		
		Если Лев(Значение, 1) = """" Тогда
			
			Значение = СтрЗаменить(Значение, """", "");
			
		ИначеЕсли Лев(Значение, 1) = "{" Тогда
			
			Значение = ЗначениеИзСтрокиВнутр(Значение);
			
		Иначе
			
			Попытка

				Значение = Число(Значение);
			
			Исключение

				Возврат 0;
				
			КонецПопытки;
			
		КонецЕсли;
	КонецЕсли;
    
	Возврат 1;
	
КонецФункции
//*******************************************
Функция СериализоватьОбъектРекурсивно(Объект, хмлПарсер, хмлКорень, Знач хмлНаборСхем,
	хмлШаблон="", спОбъектов="", URIПрефикс="myType", ОписаниеТипа="", Ид="") Экспорт
	Перем хмлУзел, хмлROOT, хмлРезультат; 
	
	Если спОбъектов = "" Тогда
		спОбъектов = СоздатьОбъект("СписокЗначений");
	КонецЕсли;	
	
	Если ТипЗначенияСтр(Объект) = "OLE.IXMLDOMElement" Тогда
		Результат = 1;
		хмлУзел = Объект;
	Иначе
		Результат = СериализоватьОбъект(Объект, 
			хмлПарсер, хмлНаборСхем, хмлУзел, ОписаниеТипа, Ид);
		Если Результат = 0 Тогда
			Возврат Результат;
		КонецЕсли;	
	КонецЕсли;		
	
	Если хмлШаблон <> "" Тогда
		Результат = СоздатьЭлементДокумента(хмлРезультат, 
			хмлНаборСхем, хмлROOT);
		хмлROOT.appendChild(хмлУзел);
		Результат = ВыполнитьПреобразование(хмлРезультат, 
			хмлНаборСхем, хмлШаблон, хмлУзел);
		// ошибки здесь не будет, ее нужно искать в шаблоне...	
		Если хмлУзел.childNodes.length > 1 Тогда	
			хмлУзел = хмлУзел.childNodes(1);	
		Иначе
			Возврат 1;
		КонецЕсли;	
	КонецЕсли;	
		
	Если Результат = 1 Тогда
		стрХСЛ = "<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" 
		|xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:myType=""http://my.org/buh"">
		|<xsl:template match=""/"">
		|<ROOT>
		|	<xsl:for-each select="".//* "">
		|		<xsl:variable name=""node"" select=""name()""/>
		|		<xsl:variable name=""value"" select="".""/>
		|		<xsl:for-each select=""@*[contains(name(),'xsi:type')]"">
		|			<xsl:element name=""{$node}"">
		|				<xsl:attribute name=""{name()}"">
		|					<xsl:value-of select="".""/>
		|				</xsl:attribute>
		|				<xsl:value-of select=""$value""/>
		|			</xsl:element>
		|		</xsl:for-each>
		|	</xsl:for-each>
		|</ROOT>
		|</xsl:template>
		|</xsl:stylesheet>
		|";
		хмлХСЛ = ""; 
		хмлУзелРазвернут = "";
		Результат = ПрочитатьДокументИзСтроки(хмлРезультат, хмлНаборСхем, , 
			хмлУзел.xml) * ПрочитатьДокументИзСтроки(хмлХСЛ, хмлНаборСхем, , 
				стрХСЛ) * ВыполнитьПреобразование(хмлРезультат,	хмлНаборСхем, 
					хмлХСЛ, хмлУзелРазвернут);

		хмлУзелРазвернут = хмлУзелРазвернут.childNodes(1);
		Если Результат = 1 Тогда
			Для номАтр = 0 По хмлУзелРазвернут.childNodes.length - 1 Цикл
				хмлАтрибут = хмлУзелРазвернут.childNodes(номАтр);
		
				ОписаниеТипа = "";
				Попытка
					Тип = хмлАтрибут.attributes.getNamedItem("xsi:type");
					ОписаниеТипа = Тип.text;
				Исключение
				КонецПопытки;
				Если СтрЧислоВхождений(ОписаниеТипа, URIПрефикс)>0 Тогда
					Значение = ЗначениеИзСтрокиВнутр(хмлАтрибут.text);
					Если ПустоеЗначение(Значение) = 0 Тогда
						//Если СтрЧислоВхождений(ОписаниеТипа, "F")>0 Тогда
						//	Результат = СериализоватьОбъектРекурсивно(Значение, хмлПарсер, 
						//		хмлКорень, хмлНаборСхем, хмлШаблон, спОбъектов, , 
						//			ОписаниеТипа, хмлАтрибут.text);
						//Иначе	
						//	Если спОбъектов.НайтиЗначение(Значение) = 0 Тогда 
							Если спОбъектов.НайтиЗначение(хмлАтрибут.text) = 0 Тогда
						//		спОбъектов.ДобавитьЗначение(Значение); 
								спОбъектов.ДобавитьЗначение(хмлАтрибут.text);
								Результат = СериализоватьОбъектРекурсивно(Значение, хмлПарсер, 
									хмлКорень, хмлНаборСхем, хмлШаблон, спОбъектов, , 
										ОписаниеТипа, хмлАтрибут.text);
						//	КонецЕсли;		
						КонецЕсли;		
					КонецЕсли;		
				КонецЕсли;
			КонецЦикла;
		Иначе
			Сообщить("Ошибка!");
		КонецЕсли;
		
		// пустой узел объекта - 
		// 	результат работы "фильтра"
		Если хмлУзел.childNodes.length > 0 Тогда
			хмлКорень.appendChild(хмлУзел);
		КонецЕсли;	
		//\\
		
	Иначе
		Сообщить("Ошибка при сериализации: " + Объект);
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции
//*******************************************
Функция Таб2Структура(ТЗ)
	Перем хмлПарсер, хмлКорень;
	
	СоздатьЭлементДокумента(хмлПарсер, 
		"", хмлКорень, "ROOT", "windows-1251");
	
    ТЗ.ВыбратьСтроки();
	Пока ТЗ.ПолучитьСтроку() = 1 Цикл
	    
		Имя = ТЗ.Имя;
		Для П = 1 По СимвИсключения.РазмерСписка() Цикл
			Имя = СтрЗаменить(Имя, 
				СимвИсключения.ПолучитьЗначение(П), "");
		КонецЦикла;
			
		хмлУзел = хмлКорень.appendChild(хмлПарсер
			.createElement(Имя));
			
		хмлУзел.text = ТЗ.Значение;	
		
	КонецЦикла;
	
	Возврат хмлПарсер;
		
КонецФункции
//*******************************************
Функция Таб2Иерархия(ТЗ, хмлПарсер = "", тзРеквизит = "", ВыбДата = "") Экспорт
	Перем хмлКорень;
	
	Если тзРеквизит <> "" Тогда
		хмлРеквизит = Таб2Структура(тзРеквизит);
		
		ТипОбъекта = СтрЗаменить(хмлРеквизит
			.SelectSingleNode("ROOT/ПолныйИдентификатор")
				.text, "." + хмлРеквизит.SelectSingleNode(
					"ROOT/Идентификатор").text, "");

		Объект = СоздатьОбъект(ТипОбъекта);
		Объект.ИспользоватьДату(?(ВыбДата = "", 
			ТекущаяДата(), ВыбДата));
	КонецЕсли;	
	
	Если хмлПарсер = "" Тогда
		СоздатьЭлементДокумента(хмлПарсер, 
			"", хмлКорень, "ROOT", "windows-1251");
		
		хмлУзел = хмлКорень.appendChild(хмлПарсер
			.createElement("_____0___"));
			
		Если тзРеквизит <> "" Тогда	
			ДобавитьАтрибут(хмлПарсер, хмлУзел, "Value", 
				ПолучитьПустоеЗначение(хмлРеквизит
					.SelectSingleNode("ROOT/Тип").text));
		КонецЕсли;
	КонецЕсли;
	
	Н = 1;
	Пока Н <= ТЗ.КоличествоСтрок() Цикл
		ТЗ.ПолучитьСтрокуПоНомеру(Н);

		Выборка = хмлПарсер.SelectNodes("//" 
			+ СтрЗаменить(ТЗ.Parent, " ", "_"));
			
		Если Выборка.length <> 0 Тогда
			хмлУзел = Выборка.item(0).appendChild(хмлПарсер
				.createElement(СтрЗаменить(ТЗ.Node, 
					" ", "_")));
			
			Если тзРеквизит <> "" Тогда
				Объект.НайтиЭлемент(глмМетаданные
					.Ид2Ссылка(глмМетаданные
						.КодИБ2Ид(ТипОбъекта, ТЗ.Node)));
						
				Значение = Объект.ПолучитьАтрибут(хмлРеквизит
					.SelectSingleNode("ROOT/Идентификатор").text);
					
				Если ПустоеЗначение(Значение) = 1 Тогда
					Значение = Выборка.item(0).attributes
						.getNamedItem("Value").text;
				КонецЕсли;
					
				ДобавитьАтрибут(хмлПарсер, хмлУзел, 
					"Value", Значение);
			КонецЕсли;
			
			ТЗ.УдалитьСтроку(Н);
		Иначе
			Н = Н + 1;
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат ?(ТЗ.КоличествоСтрок() = 0, хмлПарсер,
		Таб2Иерархия(ТЗ, хмлПарсер, тзРеквизит, ВыбДата));
	
КонецФункции
//*******************************************
Функция Иерархия2Таб(хмлПарсер, Узел, тзРеквизит = "")
	
	ТЗ = СоздатьОбъект("ТаблицаЗначений");
	ТЗ.НоваяКолонка("Node", "Строка", 9, 0);
	
	Если тзРеквизит <> "" Тогда
		
		хмлРеквизит = Таб2Структура(тзРеквизит);
		ТЗ.НоваяКолонка("Value", хмлРеквизит
			.SelectSingleNode("ROOT/Тип").text, хмлРеквизит
				.SelectSingleNode("ROOT/Длина").text, хмлРеквизит
					.SelectSingleNode("ROOT/Точность").text);
		
	КонецЕсли;	
	
	// сам узел ...
	Выборка = хмлПарсер.SelectNodes("//" 
		+ СтрЗаменить(Узел, " ", "_"));
	
	ТЗ.НоваяСтрока();
	ТЗ.Node = СтрЗаменить(Выборка.item(0)
		.tagName, "_", " ");
	Если тзРеквизит <> "" Тогда	
		ТЗ.Value = Выборка.item(0).attributes
			.getNamedItem("Value").text;
	КонецЕсли;	
		
	// ... и его потомки	
	Выборка = хмлПарсер.SelectNodes("//" 
		+ СтрЗаменить(Узел, " ", "_") + "//*");
	
	Для Н = 1 По Выборка.length() Цикл
		ТЗ.НоваяСтрока();
		ТЗ.Node = СтрЗаменить(Выборка.item(Н-1)
			.tagName, "_", " ");
		Если тзРеквизит <> "" Тогда	
			ТЗ.Value = Выборка.item(Н-1).attributes
				.getNamedItem("Value").text;	
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат ТЗ;
	
КонецФункции	
//*******************************************
Функция ВыполнитьТекстовыйЗапрос(хмлПарсер, ТекстЗапроса)
	Перем хмлФункция, хмлРезультат;
		
	ПрочитатьДокументИзСтроки(хмлФункция, "", "", ТекстЗапроса);
	
	Атрибуты = хмлПарсер.documentElement.attributes;
    
	Для Н = 1 По Атрибуты.length() Цикл
		Если СтрЧислоВхождений(Атрибуты.item(Н-1).name, "xmlns:") > 0 Тогда
			ДобавитьАтрибут(хмлФункция, хмлФункция.documentElement, 
				Атрибуты.item(Н-1).name, Атрибуты.item(Н-1).value);
		КонецЕсли;		
	КонецЦикла;	
	
	ВыполнитьПреобразование(хмлПарсер, "", хмлФункция, хмлРезультат);
	
	Возврат хмлРезультат;
	
КонецФункции	
//*******************************************
Функция ПрочитатьДирективыИмпортаСервиса(хмлОписаниеСервиса)
	
	Возврат ВыполнитьТекстовыйЗапрос(хмлОписаниеСервиса, 
		"<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
		|<xsl:template match=""/"">
		|<ROOT>
		|	<xsl:for-each select="".//* "">
		|		<xsl:for-each select=""*[contains(name(),'import')]"">
		|			<xsl:element name=""{@schemaLocation}"">
		|				<xsl:value-of select=""@namespace""/> 
		|			</xsl:element>
		|		</xsl:for-each>
		|	</xsl:for-each>
		|</ROOT>
		|</xsl:template>
		|</xsl:stylesheet>
		|");
	
КонецФункции	
//*******************************************
Функция ПрочитатьСообщенияСервиса(хмлОписаниеСервиса)
	
	Возврат ВыполнитьТекстовыйЗапрос(хмлОписаниеСервиса, 
		"<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
		|<xsl:template match=""/"">
		|<ROOT>
		|	<xsl:for-each select="".//* "">
		|		<xsl:for-each select=""*[contains(name(),':message')]"">
		|			<xsl:element name=""{@name}"">
		|				<xsl:for-each select=""*[contains(name(),':part')]"">
		|                       <xsl:element name=""{@element}"">
		|							<xsl:value-of select=""@name""/> 
		|						</xsl:element>
		|				</xsl:for-each>
		|			</xsl:element>
		|		</xsl:for-each>
		|	</xsl:for-each>
		|</ROOT>
		|</xsl:template>
		|</xsl:stylesheet> 
		|");
	
КонецФункции	
//*******************************************
Функция ПрочитатьАдресСервиса(хмлОписаниеСервиса)
	
	Возврат ВыполнитьТекстовыйЗапрос(хмлОписаниеСервиса, 
		"<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
		|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
		|<xsl:template match=""/"">
		|<ROOT>
		|	<xsl:for-each select="".//* "">
		|		<xsl:for-each select=""*[contains(name(),':address')]"">
		|			<xsl:element name=""address"">
		|				<xsl:value-of select=""@location""/>
		|			</xsl:element>
		|		</xsl:for-each>  
		|	</xsl:for-each> 
		|</ROOT>
		|</xsl:template>
		|</xsl:stylesheet>
		|");
	
КонецФункции	
//*******************************************
Функция НайтиОписаниеСообщенияСервиса(КаталогПроекта, Сообщение)
	Перем хмлОписаниеСервиса, хмлФункция, хмлРезультат;
	
	сзОписаниеСообщения = СоздатьОбъект("СписокЗначений");
	
	ФС.УстТекКаталог(КаталогПроекта);
	ВебСервис = ФС.НайтиПервыйФайл("*.wsdl");
	
	Пока ПустоеЗначение(ВебСервис) = 0 Цикл
		
    	ПрочитатьДокументИзФайла(хмлОписаниеСервиса, "", "", КаталогПроекта + ВебСервис);

		хмлСообщения = ПрочитатьСообщенияСервиса(хмлОписаниеСервиса); 
	
		Выборка = хмлСообщения.SelectNodes("//" + Сообщение);

		Если Выборка.length() > 0 Тогда

			хмлУзелСообщения = Выборка.item(0);
	        
			хмлОписаниеСообщения = хмлУзелСообщения.childNodes(0);
			
			сзОписаниеСообщения.ДобавитьЗначение(хмлОписаниеСообщения.tagName, 		"Имя");
			сзОписаниеСообщения.ДобавитьЗначение(хмлОписаниеСообщения.prefix, 		"Префикс");
			сзОписаниеСообщения.ДобавитьЗначение(хмлОписаниеСообщения.namespaceURI, "ПространствоИмен");                  
			
			хмлАдрес = ПрочитатьАдресСервиса(хмлОписаниеСервиса);
			сзОписаниеСообщения.ДобавитьЗначение(хмлАдрес.documentElement.text, 	"Адрес");
			
			хмлДирективы = ПрочитатьДирективыИмпортаСервиса(хмлОписаниеСервиса); 
	
			стрХСЛ = "<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
				|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
				|<xsl:template match=""child::node()"">
				|	<xsl:variable name=""node"" select=""*[contains(.,'" + хмлОписаниеСообщения.namespaceURI + "')]""/>
				|			<xsl:element name=""fileName"">
				|				<xsl:value-of select=""name($node)""/>
				|			</xsl:element>
				|</xsl:template>
				|</xsl:stylesheet>
				|"; 
		
			ПрочитатьДокументИзСтроки(хмлФункция, "", , стрХСЛ);
			ВыполнитьПреобразование(хмлДирективы, "", хмлФункция, хмлРезультат);
			
			сзОписаниеСообщения.ДобавитьЗначение(хмлРезультат.documentElement.text, "ИмяФайла");
			
			Прервать;
			
		КонецЕсли;	
		
		ВебСервис = ФС.НайтиСледующийФайл();
		
	КонецЦикла;	
    
	Возврат сзОписаниеСообщения;
	
КонецФункции
//*******************************************
Функция НайтиАлиасПространстваИмен(хмлПарсер, ПространствоИмен)
	
	Для Н=1 По хмлПарсер.documentElement.attributes.length Цикл
		
		Если хмлПарсер.documentElement.attributes(Н-1).value = ПространствоИмен Тогда
		
			Возврат СтрЗаменить(хмлПарсер.documentElement.attributes(Н-1).name, "xmlns:", ""); 
			
		КонецЕсли;	
		
	КонецЦикла;
	
КонецФункции	
//*******************************************
Процедура ДобавитьСхемуИзФайлаРекурсивно(хмлНаборСхем, ПространствоИмен, Каталог, ИмяФайла) Экспорт
	Перем хмлПарсер;
	
	ДобавитьСхемуИзФайла(хмлНаборСхем, ПространствоИмен, Каталог + ИмяФайла);
	
	ПрочитатьДокументИзФайла(хмлПарсер, "", "", Каталог + ИмяФайла);
    
	хмлДирективы = ПрочитатьДирективыИмпортаСервиса(хмлПарсер);
	
	Для Н = 1 По хмлДирективы.documentElement.childNodes.length Цикл
		
		хлмДиректива = хмлДирективы.documentElement.childNodes(Н-1);

		// метод "установить" не срабатывает
		Если ПустоеЗначение(ПространстваИмен.Получить(хлмДиректива.text)) = 1 Тогда

			ПространстваИмен.ДобавитьЗначение(НайтиАлиасПространстваИмен(хмлПарсер,
				хлмДиректива.text), хлмДиректива.text);
			
			ДобавитьСхемуИзФайлаРекурсивно(хмлНаборСхем, 
				хлмДиректива.text, Каталог, хлмДиректива.tagName);
				
		КонецЕсли;	
	КонецЦикла;	
	
КонецПроцедуры
//*******************************************
Функция РассчитатьПуть(сзСтекТегов)
	
	Путь = "";
	
	Для П = 1 По сзСтекТегов.РазмерСписка() Цикл
		
		Путь = Путь + "\" + сзСтекТегов.ПолучитьЗначение(П);
		
	КонецЦикла;	
	
	Возврат Путь;
	
КонецФункции
//*******************************************
Функция ФильтрПути(сзСтекТегов, сзПути)
	
	стрПуть = РассчитатьПуть(сзСтекТегов);
	
	Для П = 1 По сзПути.РазмерСписка() Цикл
		
		ТекФильтр = сзПути.ПолучитьЗначение(П);
		
		Если ТекФильтр = Лев(стрПуть, 
			СтрДлина(ТекФильтр)) Тогда
				
				Возврат 1;
		КонецЕсли;	
		
	КонецЦикла;	
	
	Возврат 0;
	
КонецФункции
//*******************************************
Функция ВырезатьЭлементы(Данные, сзПути, сзСтекТегов = "", Имя = "", ТегОткрыт = 0, Рез = "") Экспорт
	
	Если сзСтекТегов = "" Тогда
    // полный путь элемента
		сзСтекТегов = СоздатьОбъект("СписокЗначений");
	КонецЕсли;	
	
	Если ТипЗначенияСтр(Данные) = "Текст" Тогда
		
		КолвоСтрок = Данные.КоличествоСтрок();
		
		Для НомСтр = 1 По КолвоСтрок Цикл
	        
			Состояние("Обработка строки: " + НомСтр 
				+ " из " + КолвоСтрок);
	// цикл по строкам
			стр = Данные.ПолучитьСтроку(НомСтр);
			
			Рез = ВырезатьЭлементы(стр, сзПути, 
				сзСтекТегов, Имя, ТегОткрыт, Рез);

		КонецЦикла;
	Иначе
		
		Данные = СтрЗаменить(Данные, Симв(10), "");
		
	// цикл по подстроке
		Пока СтрДлина(Данные) > 0 Цикл
		
			Если ТегОткрыт = 0 Тогда
	// читаем область данных		
				
				Поз = Найти(Данные, "<");
				
				Если Поз > 0 Тогда
	// найден символ открытия тега
					Если ФильтрПути(сзСтекТегов, сзПути) = 0 Тогда
	//[1]: добавление фрагмента данных до закрывающего тега				
						Рез = Рез + Лев(Данные, Поз - 1);	
					КонецЕсли;
					
					Имя = "";
					
					Данные = Прав(Данные, СтрДлина(Данные) - Поз);
					
					ТегОткрыт = 1;
					
				Иначе
	// вся оставшаяся часть строки
	// содержит только данные
					Если ФильтрПути(сзСтекТегов, сзПути) = 0 Тогда
	//[2]: добавление фрагмента данных после ...							
						Рез = Рез + Данные;
					КонецЕсли;	
		
					Данные = "";
		
				КонецЕсли;	
		
			Иначе
	// читаем имя тега
			    
				Поз = Найти(Данные, ">");
				
				Если Поз > 0 Тогда
	// найден символ закрытия тега			
					
					Имя = Имя + Лев(Данные, Поз - 1);
					
					Данные = Прав(Данные, СтрДлина(Данные) - Поз);
					
					ТегОткрыт = 0;
					
					Если Лев(Имя, 1) = "/" Тогда
	// закрывающий тег
						Если ФильтрПути(сзСтекТегов, сзПути) = 0 Тогда
	//[3]: добавление тега				
							Рез = Рез + "<" + Имя + ">";	
						КонецЕсли;

						сзСтекТегов.УдалитьЗначение(сзСтекТегов.РазмерСписка());
		
					Иначе
	// открывающий тег
						Если Прав(Имя, 1) <> "/" Тогда
	// если не пустой тег					
							тИмя = СтрЗаменить(Имя, " ", РазделительСтрок);
							
							сзСтекТегов.ДобавитьЗначение(СтрПолучитьСтроку(тИмя, 1));

							Если ФильтрПути(сзСтекТегов, сзПути) = 0 Тогда
	//[3]: добавление тега				
								Рез = Рез + "<" + Имя + ">";	
							КонецЕсли;
						    
						КонецЕсли;
						
					КонецЕсли;	
					
				Иначе
	// вся оставшаяся часть строки
	// содержит только имя тега
		
					Имя = Имя + Данные;
					
					Данные = "";
					
				КонецЕсли;	
		
			КонецЕсли;	               
			
		КонецЦикла;
		
	КонецЕсли;	
	
	Возврат Рез;
	
КонецФункции
//*******************************************
Процедура Сформировать()
    Перем хмлПарсер, хмлНаборСхем, хмлКорень;
	
	ОчиститьОкноСообщений();
	
	//Если СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень) = 1 Тогда
	//	Сообщить(ВывестиДокументВСтроку(хмлПарсер));
	//КонецЕсли;	
	
	//Стр = "<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
	//	|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
	//	|<xsl:apply-templates select=""*@""/>
	//	|<xsl:template match=""//ROOT/@"">
	//	|    <xsl:element name=""{name()}"">
	//	|        <xsl:value-of select=""text()""/>
	//	|    </xsl:element>
	//	|</xsl:template>
	//	|</xsl:stylesheet>
	//	|";
	//
	//Если ПрочитатьДокументИзСтроки(хмлПарсер, хмлНаборСхем, , Стр) = 1 Тогда
	//	Сообщить(ВывестиДокументВСтроку(хмлПарсер));
	//КонецЕсли;	
	
	//Если ПрочитатьДокументИзФайла(хмлПарсер, хмлНаборСхем, , 
	//	"X:\TEST\xml\tutorial\proba2.xsl") = 1 Тогда
	//		Сообщить(ВывестиДокументВСтроку(хмлПарсер));
	//КонецЕсли;
	
	//Попытка
	//	Результат = СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень)
	//		* ДобавитьСхемуИзФайла(хмлНаборСхем, "http://my.org/kassa", 
	//			"X:\TEST\my.org_kassa.xsd");
	//Исключение
	//	Сообщить("Ошибка: " + ОписаниеОшибки(), "!");		
	//	Возврат;
	//КонецПопытки;
	//
	//Если Результат = 1 Тогда
	//	хмлУзел = ПостроитьУзелПоОписаниюТипа(хмлПарсер, 
	//		хмлНаборСхем, ПолучитьОписаниеТипаСхемы(хмлНаборСхем, "http://my.org/kassa", 
	//			"DocumentObject.ОперацияБух"), 
	//				"DocumentObject.ОперацияБух");
	//	хмлКорень.appendChild(хмлУзел);			
	//	Сообщить(ВывестиДокументВСтроку(хмлПарсер));
	//	//Сообщить(хмлПарсер.prefix("http://my.org/kassa"));
	//Иначе
	//	Сообщить("Ошибка!", "!");
    //КонецЕсли;
	
	//Док = СоздатьОбъект("Документ");
	//Док.НайтиПоНомеру("ПНк-001523", Дата(2015,01,01), 
	//	"ПриходнаяНакладная");
	//
	//Накл = СоздатьОбъект("Документ.ПриходнаяНакладная");
	//Накл.НайтиДокумент(Док.ТекущийДокумент());  
	Товары = СоздатьОбъект("Справочник.Номенклатура");
	Товары.НайтиПоКоду(3069);
	//
	хмлУзел = "";
	Попытка
		Результат = СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень)
	    	//* СериализоватьОбъект(Накл.ТекущийДокумент(), хмлПарсер, хмлНаборСхем, 
	    	//* СериализоватьОбъект(Перечисление.ЕдиницыИзмерения.Штука, хмлПарсер, хмлНаборСхем, 
			* СериализоватьОбъект(Товары.ТекущийЭлемент(), хмлПарсер, хмлНаборСхем, 
				хмлУзел);
	Исключение
		Возврат;
	КонецПопытки;
	
	Если Результат = 1 Тогда
		хмлКорень.appendChild(хмлУзел);
		ВывестиДокументВФайл(хмлПарсер, "X:\TEST\test.xml");
	Иначе
		Сообщить("Ошибка!", "!");
	КонецЕсли;
	
	МенеджерОбъекта1С = "";
	
	Если ПрочитатьОбъект(МенеджерОбъекта1С, хмлПарсер, хмлНаборСхем, хмлУзел) = 1 Тогда
		
		Сообщить(МенеджерОбъекта1С);
		
	КонецЕсли;
	
	//
	////хмлФункция=""; хмлРезультат="";
	////
	////стрХСЛ =	"<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
	////			|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">
	////			|<xsl:template match=""/"">
	////			//|<ROOT>
	////			|<xsl:for-each select=""ROOT/Документ.РасходнаяНакладная/РеквизитШапки"">
	////			|<Документ.РасходнаяНакладная>
	////			|<РеквизитШапки>
	////			|<Валюта><xsl:value-of select=""Валюта""/></Валюта>
	////			|</РеквизитШапки>
	////			|</Документ.РасходнаяНакладная>
	////			|</xsl:for-each>
	////			|<xsl:for-each select=""ROOT/Справочник.Номенклатура/Реквизит"">
	////			|<CatalogObject.Номенклатура>
	////			|<Наименование><xsl:value-of select=""КодСоответствия""/></Наименование>
	////			|</CatalogObject.Номенклатура>
	////			|</xsl:for-each>
	////			//|</ROOT>
	////			|</xsl:template>
	////			|</xsl:stylesheet>
	////			|";
	////Попытка			
	////	Результат = ПрочитатьДокументИзСтроки(хмлФункция, хмлНаборСхем, , стрХСЛ)
	////		* ВыполнитьПреобразование(хмлПарсер, хмлНаборСхем, хмлФункция, хмлРезультат);
	////Исключение
	////	Сообщить("Ошибка", "!");		
	////	Возврат;
	////КонецПопытки;
	//
	////Если Результат = 1 Тогда
	////	Сообщить(ВывестиДокументВСтроку(хмлРезультат));
	////КонецЕсли;				
    //
	//МенеджерОбъекта1С = "";
	//
	//Если ПрочитатьОбъект(МенеджерОбъекта1С, хмлПарсер, хмлНаборСхем, хмлУзел) = 1 Тогда
	//	
	//	Сообщить(МенеджерОбъекта1С);
	//	
	//КонецЕсли;	
	
	//Док = СоздатьОбъект("Документ");
	//Док.НайтиПоНомеру("822.06/роз", Дата(2015,06,30), 
	//	"РасходнаяНакладная");
	//
	//Накл = СоздатьОбъект("Документ.РасходнаяНакладная");
	//Накл.НайтиДокумент(Док.ТекущийДокумент());
	//
	//спрТовары = СоздатьОбъект("Справочник.Номенклатура");
	//спрТовары.НайтиПоКоду(5192);
	//
	//
	//хмлШаблон="";
	////стрХСЛ =	"<?xml version=""1.0"" encoding=""WINDOWS-1251""?>
	////			|<xsl:stylesheet version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
	////			|<xsl:template match=""/"">
	////			//|<ROOT>
	////			|<xsl:for-each select=""ROOT/Документ.РасходнаяНакладная/РеквизитШапки"">
	////			|<Документ.РасходнаяНакладная>
	////			|<РеквизитШапки>
	////			|<Валюта xsi:type=""myType""><xsl:value-of select=""Валюта""/></Валюта>
	////			|</РеквизитШапки>
	////			|</Документ.РасходнаяНакладная>
	////			|</xsl:for-each>
	////			|<xsl:for-each select=""ROOT/Справочник.Валюты/РеквизитСтандартный"">
	////			|<Справочник.Валюты>
	////			|<РеквизитСтандартный>
	////			|<Наименование><xsl:value-of select=""Наименование""/></Наименование>
	////			|</РеквизитСтандартный>
	////			|</Справочник.Валюты>
	////			|</xsl:for-each>
	////			//|</ROOT>
	////			|</xsl:template>
	////			|</xsl:stylesheet>
	////			|";
	//
	//Попытка
	//	Результат = СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень)
	//		//* ПрочитатьДокументИзСтроки(хмлШаблон, хмлНаборСхем, , стрХСЛ)
	//		* ПрочитатьДокументИзФайла(хмлШаблон, хмлНаборСхем, "", "X:\TEST\xml\test.xsl")
	//    		* СериализоватьОбъектРекурсивно(Накл.ТекущийДокумент(), хмлПарсер, 
	//				хмлКорень, хмлНаборСхем, хмлШаблон);
	//Исключение
	//	Сообщить(ОписаниеОшибки());		
	//	Результат = 0;
	//КонецПопытки;
	//
	//Если Результат = 1 Тогда
	//	ВывестиДокументВФайл(хмлПарсер, "X:\TEST\xml\test.xml");
	//Иначе
	//	Сообщить("Ошибка!", "!");
    //КонецЕсли;
//	
//	Попытка
//		Результат = СоздатьЭлементДокумента(хмлПарсер, хмлНаборСхем, хмлКорень)
//			* ДобавитьСхемуИзФайла(хмлНаборСхем, "http://my.org/kassa", 
//				"X:\TEST\my.org_kassa.xsd");
//	Исключение
//		Сообщить("Ошибка: " + ОписаниеОшибки(), "!");		
//		Возврат;
//	КонецПопытки;
//	
//	Если Результат = 1 Тогда
//		
//		// набор записей регистра бухгалтерии
//		хмлУзел = ПостроитьУзелПоОписаниюТипа(хмлПарсер, 
//			хмлНаборСхем, ПолучитьОписаниеТипаСхемы(хмлНаборСхем, "http://my.org/kassa", 
//				"AccountingRegisterRecordSet.Хозрасчетный"), 
//					"AccountingRegisterRecordSet.Хозрасчетный");
//
//		хмлКорень.appendChild(хмлУзел);			
//
//		// фильтр		
//		хмлФильтр = ПостроитьУзелПоОписаниюТипа(хмлПарсер, 
//			хмлНаборСхем, ПолучитьОписаниеТипаСхемы(хмлНаборСхем, "http://my.org/kassa", 
//				"FilterItem"), "FilterItem");
//		
//		хмлУзел.getElementsByTagName("Filter").item(0).appendChild(хмлФильтр);
//					
//		хмлЭлемент = хмлФильтр.appendChild(хмлПарсер.createElement("Name"));
//		хмлЭлемент.text = "Recorder";			
//		
//		хмлЭлемент = хмлФильтр.appendChild(хмлПарсер.createElement("ComparisonType"));
//		хмлЭлемент.text = "Equal";			
//		
//		хмлЭлемент = хмлФильтр.appendChild(хмлПарсер.createElement("Value"));
//		хмлЭлемент.text = ЗначениеВСтрокуВнутр(Накл.ТекущийДокумент());			
//		
//		// запись
//		хмлЗапись = ПостроитьУзелПоОписаниюТипа(хмлПарсер, 
//			хмлНаборСхем, ПолучитьОписаниеТипаСхемы(хмлНаборСхем, "http://my.org/kassa", 
//				"AccountingRegisterRecord.Хозрасчетный"), 
//					"AccountingRegisterRecord.Хозрасчетный");
//		
//		хмлУзел.getElementsByTagName("Records").item(0).appendChild(хмлЗапись);
//					
//		хмлЭлемент = хмлЗапись.getElementsByTagName("Period").item(0);
//		хмлЭлемент.text = ТекущаяДата();
//		ДобавитьАтрибут(хмлПарсер, хмлЭлемент, "xsi:type", "xsi:datetime");
//		
//		хмлЭлемент = хмлЗапись.getElementsByTagName("Организация").item(0);
//		хмлЭлемент.text = ЗначениеВСтрокуВнутр(Константа.ОсновнаяФирма1);
//		ДобавитьАтрибут(хмлПарсер, хмлЭлемент, "xsi:type", "myType:Справочник.Фирмы");
//		
//		// субконто
//		хмлСубконто = ПостроитьУзелПоОписаниюТипа(хмлПарсер, 
//			хмлНаборСхем, ПолучитьОписаниеТипаСхемы(хмлНаборСхем, "http://my.org/kassa", 
//				"AccountingRegisterExtDimension.Хозрасчетный"), 
//					"AccountingRegisterExtDimension.Хозрасчетный");
//		
//		хмлЗапись.getElementsByTagName("ExtDimensionsDr").item(0).appendChild(хмлСубконто);
//					
//		хмлСубконто.getElementsByTagName("Type").item(0).text = "Справочник.Номенклатура";
//		хмлЗначение = хмлСубконто.getElementsByTagName("Value").item(0); 
//		хмлЗначение.text = ЗначениеВСтрокуВнутр(спрТовары.ТекущийЭлемент());
//		ДобавитьАтрибут(хмлПарсер, хмлЗначение, "xsi:type", "myType:Справочник.Номенклатура");
//		
//		// запись в файл для сравнения
//		ВывестиДокументВФайл(хмлПарсер, "X:\TEST\xml\test.xml");
//		
//		// преобразование объекта по схеме обмена
//		хмлШаблон = "";
//		ПрочитатьДокументИзФайла(хмлШаблон, хмлНаборСхем, "", "X:\TEST\xml\test.xsl");
//		
//	    СериализоватьОбъектРекурсивно(хмлУзел, хмлПарсер, хмлКорень, 
//			хмлНаборСхем, хмлШаблон);
//			
//		ВывестиДокументВФайл(хмлПарсер, "X:\TEST\xml\test2.xml");
//		
//	Иначе
//		Сообщить("Ошибка!", "!");
//    КонецЕсли;
	
КонецПроцедуры
//******************************************* 
СимвИсключения = СоздатьОбъект("СписокЗначений");
СимвИсключения.ИзСтрокиСРазделителями("""("","")""");

ПространстваИмен = СоздатьОбъект("СписокЗначений");
// в дальнейшем: загрузку значений констант можно выполнять из соответствующего xml-описания
КонстантыMSXML = СоздатьОбъект("СписокЗначений");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_SCHEMA", "4096");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ATTRIBUTE", "4097");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ATTRIBUTEGROUP", "4098");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NOTATION", "4099");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_IDENTITYCONSTRAINT", "4352");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_KEY", "4353");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_KEYREF", "4354");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_UNIQUE", "4355");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ANYTYPE", "8192");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE", "8448");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_ANYTYPE", "8449");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_ANYURI", "8450");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_BASE64BINARY", "8451");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_BOOLEAN", "8452");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_BYTE", "8453");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DATE", "8454");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DATETIME", "8455");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DAY", "8456");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DECIMAL", "8457");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DOUBLE", "8458");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_DURATION", "8459");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_ENTITIES", "8460");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_ENTITY", "8461");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_FLOAT", "8462");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_HEXBINARY", "8463");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_ID", "8464");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_IDREF", "8465");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_IDREFS", "8466");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_INT", "8467");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_INTEGER", "8468");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_LANGUAGE", "8469");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_LONG", "8470");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_MONTH", "8471");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_MONTHDAY", "8472");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NAME", "8473");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NCNAME", "8474");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NEGATIVEINTEGER", "8475");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NMTOKEN", "8476");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NMTOKENS", "8477");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NONNEGATIVEINTEGER", "8478");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NONPOSITIVEINTEGER", "8479");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NORMALIZEDSTRING", "8480");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_NOTATION", "8481");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_POSITIVEINTEGER", "8482");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_QNAME", "8483");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_SHORT", "8484");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_STRING", "8485");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_TIME", "8486");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_TOKEN", "8487");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_UNSIGNEDBYTE", "8488");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_UNSIGNEDINT", "8489");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_UNSIGNEDLONG", "8490");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_UNSIGNEDSHORT", "8491");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_YEAR", "8492");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_DATATYPE_YEARMONTH", "8493");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_SIMPLETYPE", "8704");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_COMPLEXTYPE", "9216");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_PARTICLE", "16384");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ANY", "16385");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ANYATTRIBUTE", "16386");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ELEMENT", "16387");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_GROUP", "16640");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ALL", "16641");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_CHOICE", "16642");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_SEQUENCE", "16643");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_EMPTYPARTICLE", "16644");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NULL", "2048");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NULL_TYPE", "10240");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NULL_ANY", "18433");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NULL_ANYATTRIBUTE", "18434");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_NULL_ELEMENT", "18435");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_GROUP", "16388");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_ALL", "16389");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_CHOICE", "16390");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_SEQUENCE", "16391");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_EMPTYPARTICLE", "16392");
КонстантыMSXML.ДобавитьЗначение("SOMITEM_SEQUENCE", "16643");
КонстантыMSXML.ДобавитьЗначение("SCHEMAUSE_OPTIONAL", "0");
КонстантыMSXML.ДобавитьЗначение("SCHEMAUSE_PROHIBITED", "1");
КонстантыMSXML.ДобавитьЗначение("SCHEMAUSE_REQUIRED", "2");
КонстантыMSXML.ДобавитьЗначение("SCHEMACONTENTTYPE_EMPTY", "0");
КонстантыMSXML.ДобавитьЗначение("SCHEMACONTENTTYPE_TEXTONLY", "1");
КонстантыMSXML.ДобавитьЗначение("SCHEMACONTENTTYPE_ELEMENTONLY", "2");
КонстантыMSXML.ДобавитьЗначение("SCHEMACONTENTTYPE_MIXED", "3");